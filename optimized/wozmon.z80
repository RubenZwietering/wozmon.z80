;  The WOZ Monitor for the Apple 1
;  Written by Steve Wozniak in 1976

export wozmon

section "wozmon variables", hram
; note: not sure why there are seperate variables for XAM and ST,
;       seems to be working fine when they are one and the same.
; register e is now what used to be XAML 	; Last "opened" location Low
; register d is now what used to be XAMH 	; Last "opened" location High
; register e is now what used to be STL 	; Store address Low
; register d is now what used to be STH 	; Store address High
lo: 				ds 1			; Hex value parsing Low
hi: 				ds 1			; Hex value parsing High
bsav: 				ds 1			; Used to see if hex value is given
mode: 				ds 1			; $00=XAM, $74=STOR, $B8=BLOCK XAM
; register c is now what used to be the X register
; register b is now what used to be the Y register

section "wozmon other variables", wramx, align[8, 1]
in: 				ds $ff			;  Input buffer

section "wozmon code", romx
	wozmon.notcr
		cp $08				; "\b"?
		jr z, wozmon.backspace	; Yes.
		cp $1b				; ESC?
		jr z, wozmon.escape		; Yes.
		dec b				; Advance text index.
		jr nz, wozmon.nextchar 	; Auto ESC if > 255.
wozmon:
	.escape
		ld a, "\\"			; "\".
		call chrout			; Output it.
	.getline
		ld a, "\n"			; CR.
		call chrout			; Output it.
		ld b, $fe			; Initialize text index.
	.backspace
		inc b				; Back up text index.
		jr z, .getline 		; Beyond start of line, reinitialize.
	.nextchar
		call chrin			; Load character.
		ld l, b
		ld h, high(in)
		ld [hl], a 			; Add to text buffer.
		call chrout 		; Display character.
		cp "\n"				; LF?
		jr nz, .notcr 		; No.
		xor a 				; For XAM mode.
		ld b, a 			; Reset text index.
	.setblock
		add a
	.setstor
		add a				; TODO: check -> Leaves $7B if setting STOR mode.
		ldh [mode], a 		; $00 = XAM, $74 = STOR, $B8 = BLOK XAM.
	.blskip
		dec b 				; Advance text index.
	.nextitem
		ld l, b
		ld h, high(in)
		ld a, [hl] 			; Get character.
		cp "\n" 			; LF?
		jr z, .getline 		; Yes, done this line.
		cp "." 				; "."?
		jr c, .blskip 		; Skip delimiter.
		jr z, .setblock 	; Set BLOCK XAM mode.
		cp ":" 				; ":"?
		jr z, .setstor 		; Yes. Set STOR mode.
		cp "R" 				; "R"?
		jr z, .run 			; Yes. Run user program.
		xor a
		ldh [lo], a 		; $00->L.
		ldh [hi], a 		;  and H.
		ld a, b
		ldh [bsav], a 		; Save b for comparison.
	.nexthex
		ld l, b
		ld h, high(in)
		ld a, [hl] 			; Get character for hex test.
		xor "0" 			; Map digits to $0-9.
		cp 10 				; Digit?
		jr c, .dig 			; Yes.
		add $89 			; Map letter "A"-"F" to $FA-FF.
		cp $fa 				; Hex letter?
		jr c, .nothex 		; No, character not hex.
	.dig
		add a
		add a 				; Hex digit to MSD of A.
		add a
		add a
		ld c, 4 			; Shift count.
	.hexshift
		add a 				; Hex digit left, MSB to carry.
		ld hl, lo
		rl [hl] 			; Rotate into LSD.
		ld hl, hi
		rl [hl] 			; Rotate into MSD’s.
		dec c 				; Done 4 shifts?
		jr nz, .hexshift 	; No, loop.
		dec b 				; Advance text index.
		jr .nexthex 		; Check next character for hex.
	.nothex
		ldh a, [bsav]
		cp b 				; Check if L, H empty (no hex digits).
		jr z, .escape 		; Yes, generate ESC sequence.
		ldh a, [mode]
		bit 6, a 			; Test MODE byte.
		jr z, .notstor 		; B6=1 STOR, 0 for XAM and BLOCK XAM
		ldh a, [lo] 		; LSD’s of hex data.
		ld [de], a 			; Store at current ‘store index’.
		inc de 				; Increment store index.
	.tonextitem
		jr .nextitem 		; Get next command item.
	.run
		ld l, e
		ld h, d
		jp hl 				; Run at current XAM index.
	.notstor
		bit 7, a
		jr nz, .xamnext 	; B7=0 for XAM, 1 for BLOCK XAM.
		ldh a, [lo]
		ld e, a
		ldh a, [hi]
		ld d, a
	.nxtprnt
		jr nz, .prdata 		; NE means no address to print.
		ld a, "\n" 			; LF.
		call chrout 		; Output it.
		ld a, d 			; ‘Examine index’ high-order byte.
		call .prbyte 		; Output it in hex format.
		ld a, e 			; Low-order ‘examine index’ byte.
		call .prbyte 		; Output it in hex format.
		ld a, ":" 			; ":".
		call chrout 		; Output it.
	.prdata
		ld a, " " 			; Blank.
		call chrout 		; Output it.
		ld a, [de] 			; Get data byte at ‘examine index’.
		call .prbyte 		; Output it in hex format.
	.xamnext
		xor a
		ldh [mode], a 		; 0->MODE (XAM mode).
		ld a, e
		ld hl, lo
		cp [hl] 			; Compare ‘examine index’ to hex data.
		ld a, d
		ld hl, hi
		sbc [hl]
		jr nc, .tonextitem 	; Not less, so no more data to output.
		inc de
		ld a, e 			; Check low-order ‘examine index’ byte
		and $03 			;  For MOD 4=0
		jr .nxtprnt
	.prbyte
		ld l, a 			; Save A for LSD.
		swap a 				; MSD to LSD position.
		call .prhex 		; Output hex digit.
		ld a, l 			; Restore A.
	.prhex
		and $0f 			; Mask LSD for hex print.
		or "0" 				; Add "0".
		cp "0"+10 			; Digit?
		jp c, chrout 		; Yes, output it.
		add $07 			; Add offset for letter.
		jp chrout 			; Output character.